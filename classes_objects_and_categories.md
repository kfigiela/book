# Classes, objects and categories

Luna is an Object Oriented language, which means that it bases on the concept of "objects". Please keep in mind, that all the object-related concepts in Luna differ significantly from the classical Object Oriented paradigm.

Object is a collection of attributes and methods. The former contain data, while the later define the object's possible behavior. Everything in Luna is an object, including data structures, functions, types, modules and even previously mentioned code blocks. Objects with similar properties are grouped into classes and are defined by variants of a particular class.


##Algebraic data types
Classes in Luna derive formally from algebraic data types. Algebraic data type is a kind of composite type -- a type formed by combining other types. Two common sorts of algebraic data type are product and sum types, also called records and variants. Both forms are supported in Luna. Algebraic data types can be analyzed and deconstructed using pattern match mechanism.

Although algebraic data types are proven to be a very powerful tool, they are uncommon among programming languages nowadays. This situation is changing however, mainly trough recent increase of interest in functional programming paradigm, where algebraic data types originate from. The formal ideas are very simple, however both the implementation as well as the derivable features differ significantly among programming languages. In fact algebraic data types in Luna are much more flexible and easier to use, than those available for example in Haskell.

##Introduction to classes
Class is a category of objects sharing some properties and behaviors. In the simplest form you can define a new class using the `class` keyword followed by its name and body definition. The following code defines a new `Student` class, containing three fields: `name`, `surname` and `age`.

```ruby
class Student:
    name    :: String
    surname :: String
    age     :: Int

    def sayHello:
        print "Hello! My name is $name."
```
We can can create a new `Student` object the following way:
```ruby
>> s = Student "John" "Doe" 26
>> print s
Student "John" "Doe" 26
>> s.sayHello
"Hello! My name is John."
```

##Variants
Variant is an object definition. But wait a moment! If a class is a category of objects sharing some properties and behaviors, where are the variants of the `Student` class defined? In the example, there is single object definition only. In such situation Luna generates the default object description, so called the default variant. The above code is in fact translated to the following one:

```ruby
class Student:
    Student:
        name    :: String
        surname :: String
        age     :: Int

        def sayHello:
            print "Hello! My name is $name."
```

As you can see, if a class consist of single variant only, Luna allows shorter definition syntax. Every field and method declared in the class level is just copied to the variant definition. If you declare many variants within a single class, Luna copies the class-level definitions to each of them.

So what does it mean that class contains objects sharing similar properties? To answer that question, lets look at the `Bool` definition from Luna's standard library:

```ruby
class Bool:
    True
    False
```

`True` and `False` are variants, completely distinct object definitions, but they share a common property - they are the only possible values of any Boolean expression. The objects does not carry any information, so their definition is quite simple.

Much more interesting example would be to create custom rendering engine of some primitive shapes. Our renderer would support only two shapes for now, but we can easily extend it later:

```ruby
class Shape:
    Rectangle: width height x=0 y=0 :: Float
    Circle:    radius       x=0 y=0 :: Float
```

We have defined the `Shape` class, that contains all the shapes we are able to render in our toy engine for now. The shapes are `Rectangle` and `Circle` and their object definitions are provided in the code. It is worth noting, that both variants share some position information, but different geometry properties. The position information, in the form of `x` and `y` fields, is provided with default values. All variants should be defined before any other class definitions.

###Constructors
Each variant defines a constructor function. Constructor, like its name suggests, facilitates the construction of objects of that particular variant. In contrast to regular functions, constructors are always generated by the compiler and share their names with corresponding variants. Constructors are the only functions, which names start with an upper-case letter.

For each variant field, there is a distinct input argument required by the constructor. If a field is provided with a default value, the corresponding constructor argument is optional. Let's investigate the type of the `Rectangle` constructor:

```ruby
>> :t Rectangle
Rectangle :: Float Float Float=0 Float=0 => Rectangle
```

The `Rectangle` constructor takes two mandatory and two optional `Float` values and produces a new `Rectangle` object.

```ruby
>> r = Rectangle 200 100
>> print r
Rectangle 200 100 0 0
```


##Classes
In contrast to classical Object Oriented paradigm, classes in Luna do not explicitly shape the relations between objects. You can think about it like about a generalization of OOP model, where there is infinite amount of relations between objects and we choose the ones, that are useful at the moment. The relation between `Rectangle` and `Circle` is not defined anywhere in the code and there is infinite amount of possible relations to choose from, including the fact that both have properties of geometric figures or that they could be faster rasterized on GPU by our brand new renderer.

Luna does not support inheritance, but it allows overlapping classes instead. It means, that objects can belong to many classes at the same time. Classes are just categories of objects in Luna. You have met some of them already, like the integer numbers. Each number is a distinct object, so the standard library defines somehow variants of `1`, `2`, `3`. Every time you write `7`, you are using the constructor named `7` of the variant `7`! There is also a class `Int`, which all the integer numbers belong to. But there is also another class `Real` containing the `Int` one! This is a great example of overlapping categories - every `Int` belongs to `Real` but not vice versa.

Lets go back to our rendering engine. We want to provide some animation support in our library, so our objects could travel a predefined path. The path can be either a rectangle, circle or a segment between two points. We could try to define `Path` the following way:

```ruby
class Path:
    Rectangle: width height x=0 y=0 :: Float
    Circle:    radius       x=0 y=0 :: Float
    Segment:   sx sy ex ey          :: Float
```

Luna will reject the above code, because both `Rectangle` as well as `Circle` were defined earlier in this module, while variants always create new types of objects. But there is a simple way we can tell Luna to use the earlier defined ones:
```ruby
class Path:
    @Rectangle
    @Circle
    Segment: sx sy ex ey :: Float
```

Now both `Rectangle` as well as `Circle` have the type of both `Shape` and `Path` at the same time. What is even more interesting, we can declare the `Path` using different, more explicit notion. In fact the above definition is automatically converted during the compilation time to the following one:
```ruby
class Segment: sx sy ex ey :: Float
alias Path = Rectangle | Circle | Segment
```

The pipe operator `|` is used to combine classes together. Each object belongs to one or more class and for each object there is implicit declaration of its base class - the one containing objects of this particular variant only. The following code should be read the following way -- `Path` is a class defined as combination of classes `Rectangle`, `Circle` and `Segment`. In other words, `Path` is either a `Rectangle` or `Circle` or `Segment`. The whole example could be easy written using this notion exclusively:

```python
class Rectangle: width height x=0 y=0 :: Float
class Circle:    radius       x=0 y=0 :: Float
class Segment:   sx sy ex ey          :: Float
alias Shape = Rectangle | Circle
alias Path  = Rectangle | Circle | Segment
```

You have met this pattern much earlier in this document. Below you can see a hypothetical `Int` definition:

```ruby
class 0
class 1
...
alias Int = ... | -2 | -1 | 0 | 1 | 2 | ...
```
In fact it is not so far away from the real implementation from the standard library. The `Real` class is just a class of all `Int` and non-integer numbers:
```ruby
alias Real = Int | 0.1 | 0.5 | 1.7 | <other real numbers>
```

Such design is much better than the classical OOP, where we have to define a priori the class hierarchy, which often tends to be hard to refactor and maintain.

###The Class type
The earlier mentioned pipe operator `|` is just a type level function for joining classes together. The resulting combination of possible elements is called the `Class` and is of course an object. The following code snippets are equivalent:
```ruby
alias Path  = Rectangle | Circle | Segment
```
```ruby
alias Path  = Class {Rectangle, Circle, Segment}
```

The `{Rectangle, Circle, Segment}` is a set of types and is used to define the new class of values.

###The Base Class
Each variant has its own so called Base Class. It is a class that accepts objects of that particular variant only.

kazdy variant deklaruje swoj typ i swoja base cateogry zawierajaca tylko wartosci bedace nim samym lub innymi jego wartosciami. (np do Inta mozemy przekzac 1,2,3,.. lub Inta). Przeniesc przyklady i kawalki opisow z kolejnego czapteru
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO

##Existential types
Each variant defines a distinct type. That type describes a class of objects of that particular variant type. Luna tracks the usages of every variant and uses this information for better reasoning about the data flow. This is why if you ask Luna about a type of a well defined object, you often get a type that looks exactly or very similar to the investigated expression:
```ruby
:t 5
5 :: 5
:t "hello"
"hello" :: "hello"
:t Rectangle 0 0 200 100
Rectangle 0 0 200 100 :: Rectangle
:t 5
5 :: 5
```

However it is easy to break this by define such sample function:
```ruby
def area shape:
   case shape of
       Rectangle _ _ w h: w * h
       Circle    _ _ r  : pi * r^2
```
If we ask Luna for the inferred type, we will see `area :: Shape -> Float`, because it cannot be further simplified. We do not know yet if the argument will be `Rectangle` or `Circle`, but we know could get any `Float` as a result. In fact we could use smarter types in our shape definition like `Positive Int`, because the diameters cannot be negative. In such case, the type inferencer would deduce that the shape results are non-negative too.

The funny part is, that this mechanism works with any combination of variants, even not related explicitly so far. Lets look at the following function definition:
```ruby
def func x::Int :
    if x>0 then x
           else "oh no"
```
If we ask Luna about its type, we get:
```ruby
:t func
func :: Int -> Int | "oh no"
```
We should read it as follow -- function foo takes a single argument that belongs to the category of `Int` and result could be either any int or the sentence `"oh no"`. Because each possible sentence belongs to the `String` class and is defined by a distinct variant, it has also a distinct type. The type-level `"oh no"`means a class accepting a single objects only -- the string `"oh no"` itself. In fact the type checker could do a better job here, deducing the signature to be `func :: Int -> Positive Int | "oh no"`, but the inference possibilities are strongly compiler implementation dependent and doesn't affect the language features.

The type inference for categories is basically straightforward. If we are provided with a variable and we know that the possible values belong to class `Class {A, B}`, using a method `foo` on this object, we get a result that belongs to a category `Class {A.foo, B.foo}`. Because `{...}` means a set in Luna, if both the classes `A.foo` and `B.foo` would be further inferred to return values from the same category, like for example `String`, the resulting type would be simplified to just `String`.

Some other languages like Haskell allow similar functionality, but much less expressive -- it is usually named `existential types`. It allows working on arbitrary values, that implement a common, predefined interface. The idea is very powerful, but requires explicit interface specification, which is often either unclear or is often changing during a project development and adds some significant maintenance cost. In Luna on the other hand, the type system bases on the idea of categories of related objects, where the relations do not have to be expressed in the explicit way, so there is no difference between casual and existential types in Luna.
