#Objects

The concept of objects is analogous to real world objects. Object describes an entity that has a specific properties and behaviors, like a car, a lamp or a book. You can learn more about the concept in the [Category Oriented Programming](category_oriented_programming.md) chapter.

Objects are instances of object types. A new object type can be defined in Luna using the `object` function. At first glance, object definitions look very familiar! The following code defines a new `Point` object type, containing two fields – `x` and `y`.

```ruby
object Point:
    x :: Real
    y :: Real
```

Object type consist of three declaration sections – fields, variants and methods. Each section is optional and can be omitted. You will learn about variants and methods in the following chapters.

The field declaration consist always of field's name followed by explicit type information. It is possible to declare more than one field within a single line, but then the type signature is applied to every field in that line. So the above definition can be written shorter:

```ruby
object Point:
    x y :: Real
```

###Algebraic data types
Object types in Luna derive formally from algebraic data types. Algebraic data type is a kind of composite type – a type formed by combining other types. Two common sorts of algebraic data type are product and sum types, also called records and variants. Both forms are supported in Luna. Algebraic data types can be analyzed and deconstructed using pattern match mechanism.

Although algebraic data types are proven to be a very powerful tool, they are uncommon among programming languages nowadays. This situation is changing however, mainly trough recent increase of interest in functional programming paradigm, where algebraic data types originate from. The formal ideas are very simple, however both the implementation as well as the derivable features differ significantly among programming languages. In fact algebraic data types in Luna are much more flexible and easier to use than those available for example in Haskell or Scala.


###Variants
Object type consist of a set of related data definitions, so called variants.
Each variant has a distinct type being a subtype of the object type. You should think about variants like about distinct object definitions, grouped together in an object type based on some common properties.

But wait a moment! Where are the variants of the `Point` object type defined? The `Point` object type contains a single object definition only. In such situation Luna generates the default variant `Default` implicitly. The default variant is generated only when there is no explicit variant declaration. The previous code is in fact translated to the following one:

```ruby
object Point:
    Default:
        x y :: Float
```

Variant definition syntax is pretty simple. Every upper-case name in the top level of an object type body denotes new variant definition. Variant definition could contain any number of field definitions. Empty variant definitions describe objects, whose instances cannot carry any additional information.

As you can see, if an object type consist of single variant only, Luna allows some nice syntax sugar. If you explicitly declare both the fields as well as the variants, every field declared in the object type level is just copied to the beginning of each variant definition. The methods are defined for all variants and are properties of the object type.

So what does it mean that variants share some similar properties? To answer that question, lets look how `Bool` is defined in Luna's standard library!

```ruby
object Bool:
    True
    False
```

The `True` and `False` variants are completely distinct object definitions, however they share a common property – they are the only possible values of any boolean expression. They do not declare any fields, so their definition is quite simple.

###Constructors

It's time to create our first object! Each variant is associated with so called constructor function. In contrast to regular functions, constructors are always generated by the compiler and share their names with corresponding variants, which makes them the only functions with upper-case names. Moreover, you can always use the variant name as both the constructor function name as well as the variant type name.

Every constructor except the `Default` one is exported to the object type declaration scope, so you can use it without any qualification. Let's investigate the type of the `True` and `False` constructors:

```ruby
λ: :t True
   True :: True :: Bool
λ: :t False
   False :: False :: Bool
```

As we can see, both `True` as well as `False` are functions taking no arguments, resulting in a value of the `Bool` type. The names `True` and `False` were used as both the constructor names as well as the variant types.

That was simple, lets try to use the `Point`'s default constructor! For each variant field, there is a distinct input argument required by the constructor. If a field is provided with a default value, the corresponding constructor argument is optional.

```ruby
λ: type of Point.Default
   Point.Default :: Real -> Real -> Point
```

This is a function type. You will learn more about function types later in this book. For now just remember its meaning – we have to provide two `Real` arguments in order to get a new object of type `Point`. We can can use the constructor as follows:

```ruby
λ: s = Point.Default 5 6
λ: print s
   Point.Default 5 6
λ:
```

There is though some boilerplate in the code. The `Default` variant is the only constructor of the `Point` object type, so it should be possible to create the instances easier. We can call the `new` function for the rescue! The `new` function is a small utility defined in the Luna's standard library:

```ruby
def new type: type.Default ..
```

The function takes a type and calls its default constructor, passing all its parameters further to that constructor. It is especially useful with multi-constructor object types, where you just want to use the default constructor of a particular object type.

```ruby
λ: s = new Point 5 6
λ: print s
   Point.Default 5 6
```

### Explicit variants
Much more interesting example would be to create custom rendering engine of some primitive shapes. Our renderer would support only two shapes for now, but we can easily extend it later:

```ruby
object BasicShape:
    Circle:
        pos    :: Point = new Point 0 0
        radius :: Float

    Rectangle:
        pos    :: Point = new Point 0 0
        width  :: Float
        height :: Float
```

The above definition can be written much shorter in Luna:

```ruby
object BasicShape:
    pos :: Point = new Point 0 0

    Circle:    radius       :: Float
    Rectangle: width height :: Float
```

We have created the `BasicShape` object type, that contains all the shape definitions we are able to render in our toy engine for now. The shapes are defined by `Rectangle` and `Circle` variants. It is worth noting, that both variants share some position information, but different geometry properties. The position information is provided with a default value. All variants should be defined before any other class definition.

Lets create a new `Rectangle` object! We do not have to use the `new` function here, because we reference the explicit variant constructor.

```ruby
λ: s = Rectangle width  = 5
                 height = 6
```
The above code is just a `Rectangle` constructor evaluation using named parameters. The `pos` attribute was not provided, so Luna uses the default one.

```ruby
λ: print s
   Rectangle (Point.Default 0 0) 5 6
λ: print s.pos.x
   0
```

Object types could be similar to classes from Object Oriented paradigm, however neither object types nor classes in Luna do not explicitly shape the relations between objects. You can think about it like about a generalization of Object Oriented model, where there is infinite amount of relations between objects and we choose the ones, that are useful at the moment. The relation between `Rectangle` and `Circle` is not defined anywhere in the code and there is infinite amount of possible relations to choose from, including the fact that both share properties of geometric figures or that they could be faster rasterized on GPU by our brand new renderer.

#### Shared variants
Lets assume, we want to provide some animation support in our library, so our objects could travel a predefined path. The path can be either a rectangle, circle or a segment between two points. We could try to define `Path` the following way:

```ruby
object BasicShape:
    pos :: Point = new Point 0 0

    Circle:    radius       :: Float
    Rectangle: width height :: Float

object Path:
    Circle:    pos          :: Point = new Point 0 0
               radius       :: Float
    Rectangle: pos          :: Point = new Point 0 0
               width height :: Float
    Segment:   start end    :: Point
```

Luna will reject the above definition, because both variants `Rectangle` and `Circle` were defined earlier within this module. Variants declare always new object descriptions, which names cannot be the same across single module. But there is a simple way we can tell Luna that few earlier defined data types belong to a new object type as well! We call it variant sharing.

Luna does not support inheritance, but it allows overlapping classes instead.  It means, that a single object can belong to many classes at the same time. As we've mentioned earlier each object type is in fact a class definition, so the variants can be shared across multiple object definitions as well! You can use the `include` block exactly for this purpose. Every variant enumerated within the block will be included in the category of objects described by that particular object type.

```ruby
object BasicShape:
    pos :: Point = new Point 0 0

    Circle:    radius       :: Float
    Rectangle: width height :: Float

object Path:
    include: Rectangle Circle
    Segment: start end :: Point
```

Now both `Rectangle` as well as `Circle` belong to `Shape` and `Path` object types at the same time. An important fact to note is that even if the variants belong to various object types, their type is `BasicShape`. So if you create a new `Rectangle` object, it will behave like every element of the `BasicShape` type unless stated otherwise. You will learn about transferring objects between categories later.


### Pattern matching

Pattern matching is an mechanism facilitating decomposition of objects. You can use pattern matching in several parts of code including the assignment expression and function definition. The syntax of a pattern match is analogous to using the constructor function, but instead of construction it allows the deconstruction of objects.

Let's start with our `Student` object type!

```ruby
λ: s = Student 'John' 'Doe' 26
λ: Student n sn a = s
λ: print [n,sn,a]
   ['John', 'Doe', 26]
```

You can also use pattern matching to deconstruct one of several object type variants:

```ruby
λ: s = Rectangle width  = 5
                 height = 6
λ: Rectangle pos w h = s
λ: print [pos,w,h]
   [Point 0 0, 5, 6]
```

```ruby
λ: s = Rectangle width  = 5
                 height = 6
λ: Circle pos r = s
*: Pattern match type mismatch.
   Cannot match expected type Circle with actual type Rectangle.
```

Unlike many languages, Luna reports the pattern match type mismatch error during the compilation-, not run-time. It is possible, because each variant has a distinct type and Luna tracks the detailed variable type under the hood. Luna rejects every pattern match that is not guaranteed to succeed at run-time, unless you provide the compilation option `--patternmatch unsafe`. The following code will be rejected:

```ruby
λ: rect = Rectangle width  = 5
                    height = 6
λ: circ = Circle    radius = 0.1
λ: shape = random of [rect, circ]
λ: Rectangle pos w h = shape
*: Pattern match type missmatch.
   Cannot match expected type Rectangle with actual type Shape.
   Use the case expression instead.
```

Luna rejects the pattern match because it is not sure whenever the pattern match will succeed or fail. In order to pattern match in a safe way, we can use the `case` expression! The `case` expression allows testing a value against several pattern matches and choose the first one that succeed.

```ruby
λ: area = case shape of
          Rectangle _ w h: w * h
          Circle    _ r  : pi * r^2
```

The above code computes the area of shape, whenever the shape was `Rectangle` or `Circle`. As you can see, it is possible to use the wild-card operator `_` in order to omit unnecessary components.

#### Partial pattern matching
Luna rejects every case expression that is not guaranteed to succeed at run-time, unless you provide the compilation option `--casematch unsafe`. Checking if a pattern match is a total function is not an easy task, especially when working on recursive object types, so it is possible that Luna will reject a case expression that is covers all the possible use cases. In such situation we suggest using the wild-card pattern match to ensure the compiler that all the cases are handled. We are working towards improving the situation in the future Luna releases.

```ruby
λ: area = case shape of
          Rectangle _ w h: w * h
*: Non-exhaustive pattern match. The pattern (Circle ..) is not included.
```

#### Ellipsis pattern matching
Lets create a list of five elements and then pattern match on the first and the last one!

```ruby
λ: lst = [1,2,3,4,5]
λ: [a,_,_,_,b] = lst
```

Sometimes it is just convenient to pattern match on several fields while omitting the rest. You can use the ellipsis operator `..` for that purpose. The previous example could be rewritten to the following one:

```ruby
λ: lst = [1,2,3,4,5]
λ: [a,..,b] = lst
```

You can also use partial pattern matching to omit all but first pattern match component. If you want for example to take an action depending on the fact, that our shape was a `Rectangle` or a `Circle`, you can write the following code:

```ruby
λ: case shape of
        Rectangle .. : print 'It was a rectangle!'
        Circle    .. : print 'It was a circle!'
```

#### Range pattern matching
There is yet another syntax form available for pattern matches. You can use the range operator `...` in order to pattern match over ranges of objects, like all the numbers from `0` to `7`. It behaves exactly like in expressions, where you can use it to create list over ranges of objects.

```ruby
λ: num = random
λ: case num of
        1 ... 7 : print 'That was our lucky number!'
        _       : print 'Try again!'
```
